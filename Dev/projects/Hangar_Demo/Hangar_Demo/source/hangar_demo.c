#include <stdlib.h>
#include "gba_video.h"
#include "gba_systemcalls.h"
#include "gba_input.h"
#include "gba_interrupt.h"
#include "mappy.h"
#include "pcx.h"
#include "fade.h"

#include "tile.h"
#include "slug.h"
#include "hangar.h"
#include "splash_scr.h"
#include "graphics_controller.h"
#include "input_controller.h"

//---------------------------------------------------------------------------------
// header for binary data generated by bin2o macro in makefile
//---------------------------------------------------------------------------------
#include "title_pcx.h"
#include "title_pulse_pcx.h"
#include "main_menu_pcx.h"
#include "GROUND_EXP_pcx.h"

void hangar_Init();
void clearScreenblock(int sb, int filltile);
void splash_HandleInputs();
void hangar_HandleInputs();

//---------------------------------------------------------------------------------
// Function Declarations
//---------------------------------------------------------------------------------

//---------------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------------

#define SLUG_SIZE 5

#define SB_PAGE 31

Tile * tiles;
Slug * slug;

HANGAR_TILE_SIZE h_size;//< Size of the hangar's rendered tiles
int h_width;			//< Width of the hangar
int h_height;			//< Hangar of the hangar
int startGridX = 3;		//< Starting GBA tile X of slug grid
int startGridY = 3;		//< Starting GBA tile Y of slug grid

//---------------------------------------------------------------------------------
// Program entry point
//---------------------------------------------------------------------------------
int main(void)
//---------------------------------------------------------------------------------
{

	// Initialising the tiles
	h_size = HANGAR_MEDIUM;
	h_width = 5;
	h_height = 5;

	// Enable Large background, use Screenblock 31 and enable 16-color mode
	REG_BG0CNT = TEXTBG_SIZE_512x512 | SCREEN_BASE(SB_PAGE) | BG_256_COLOR;
	SetMode(MODE_0 | BG0_ON);		// screen mode & background to display

	// Load tile set and palette 
	DecodePCX(GROUND_EXP_pcx, CHAR_BASE_ADR(0), BG_PALETTE);

	tiles = Tile_InitTileMatrix(h_height, h_width);
	slug = Slug_CreateSlug(tiles, h_width, h_height, SLUG_SIZE);

	// Initialise the hangar and draw the slug
	hangar_Init();
	Hangar_DrawSlug(slug);

	// Set up the interrupt handlers
	irqInit();
	// Enable Vblank Interrupt to allow VblankIntrWait
	irqEnable(IRQ_VBLANK);

	// Load all necessary image data
	//graphics_LoadImage(title_pcx, &PaletteBuffer);
	//graphics_LoadImage(title_pulse_pcx, &PulsePaletteBuffer);

	//splash_screen_eff = splash_PulseGray;	// Set the initial screen mode
	//splash_set_pal1(&PaletteBuffer);		// Load the first palette
	//splash_set_pal2(&PulsePaletteBuffer);	// Load the second palette

	//dprintf("Initialised application with palettes %p, %p\n", &PaletteBuffer, &PulsePaletteBuffer);

	while (1)
	{
		VBlankIntrWait();
		//graphics_Update();
		// Process key inputs
		input_key_reads();
		hangar_HandleInputs();

		if (input_key_pressed(KEY_SELECT)) {

			// Create a new slug
			Slug_DestroySlug(slug);
			slug = Slug_CreateSlug(tiles, h_width, h_height, SLUG_SIZE);
		
			// Reinitialise the hangar and draw the new slug
			hangar_Init();
			Hangar_DrawSlug(slug);
		}

		// Redraws the slug
		if (input_key_pressed(KEY_START)) {
			Hangar_DrawSlug(slug);
		}

		//splash_HandleInputs();
	}

	// Frees up resources. This code will never be reached, but serves as convention to be prepared to clean up.
	free(tiles);
	Slug_DestroySlug(slug);

}

void hangar_Init() {

	// Fill the screenblock with the 
	clearScreenblock(SB_PAGE, 13);

	// Draw the slug ground map
	Hangar_DrawGroundMap(SB_PAGE, h_size, startGridX, startGridY, h_width, h_height);

	// Draw initial starting tile
	Hangar_DrawHangarTile(0, 0, 1, 0);
}

void clearScreenblock(int sb, int filltile) {
	// Map each tile in the screenblock to the fill tile
	for (int x = 0; x < 32; x++) {
		for (int y = 0; y < 32; y++) {
			MAP[SB_PAGE][y][x] = filltile;
		}
	}
}

void hangar_HandleInputs() {

	int selectX = 0;
	int selectY = 0;

	// Input handling for selected tile x-coordinate movement.
	if (input_key_pressed(KEY_LEFT)) {
		selectX--;
	}
	else if (input_key_pressed(KEY_RIGHT)) {
		selectX++;
	}

	// Input handling for selected tile y-coordinate movement
	if (input_key_pressed(KEY_UP)) {
		selectY--;
	}
	else if (input_key_pressed(KEY_DOWN)) {
		selectY++;
	}

	// Check if the user wishes to increase or decrease the hangar tile size and do so.
	if (input_key_pressed(KEY_L) && h_size > HANGAR_SMALL) {
		h_size--;
		hangar_Init();
		Hangar_InitSelector();
		Hangar_DrawSlug(slug);
	}

	if (input_key_pressed(KEY_R) && h_size < HANGAR_LARGE) {
		h_size++;
		hangar_Init();
		Hangar_InitSelector();
		Hangar_DrawSlug(slug);
	}

	// If either of the values are not 0, update the selector
	if (selectX || selectY) {
		Hangar_MoveSelector(selectX, selectY);
	}

}

void splash_HandleInputs() {
	if (input_key_pressed(KEY_UP) && splash_screen_eff != splash_PulseGray)				splash_screen_eff = splash_PulseGray;
	else if (input_key_pressed(KEY_RIGHT) && splash_screen_eff != splash_Pulse_Title)	splash_screen_eff = splash_Pulse_Title;
	else if (input_key_pressed(KEY_DOWN) && splash_screen_eff != splash_FadeOut)		splash_screen_eff = splash_FadeOut;
	else if (input_key_pressed(KEY_LEFT))												graphics_TransNewImage(main_menu_pcx);
}