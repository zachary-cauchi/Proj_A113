#include "gba_video.h"
#include "gba_systemcalls.h"
#include "gba_input.h"
#include "gba_interrupt.h"
#include "mappy.h"
#include "pcx.h"
#include "fade.h"

#include "randlib.h"
#include "splash_scr.h"
#include "graphics_controller.h"
#include "input_controller.h"

//---------------------------------------------------------------------------------
// header for binary data generated by bin2o macro in makefile
//---------------------------------------------------------------------------------
#include "title_pcx.h"
#include "title_pulse_pcx.h"
#include "main_menu_pcx.h"

void splash_HandleInputs();

typedef enum TILE_STATE {
	EMPTY = 0,
	SLUG_HERE = 1,
	SLUG_HIT,
	MISS_HIT
} TILE_STATE;

typedef struct TILE {
	u16 x;
	u16 y;
	TILE_STATE state;
} Tile;

typedef struct SLUG {
	u16 size;
	bool isActive;
	bool isDead;
	Tile ** coords;
} SLUG;

//---------------------------------------------------------------------------------
// Function Declarations
//---------------------------------------------------------------------------------

/**
 * Initialises a 2-dimensional matrix of tiles by the given width and height.
 * Returns a pointer to the final array.
 * @param width The width of the final matrix.
 * @param height The height of the final matrix.
 * @return The newly created tile matrix.
 */
Tile * InitTileMatrix(u16 width, u16 height);

#define COORDS_2D(x, xMul, y) (x * xMul) + y

/**
 * Initialises a slug based on the given Tile matrix of the given size.
 * @param map The tilemap to base the slug on.
 * @param maxWidth The maximum width of the slug, equal to or less than the width of the provided tilemap.
 * @param maxHeight The maximum height of the slug, equal to or less than the height of the provided tilemap.
 * @return The newly created slug.
 */
SLUG * CreateSlug(Tile * map, u16 maxWidth, u16 maxHeight, u16 size);

/**
 * Checks if the given tile has any empty tiles directly adjacent to it.
 * @param map A pointer to the tile array representing the map.
 * @param mapWidth The width of the map.
 * @param mapHeight The height of the map.
 * @param selectTile The tile to check.
 * @return true on the first tile found with a state equal to TILE_STATE.EMPTY.
 */
bool TileHasEmptyNeighbours(Tile * map, int mapWidth, int mapHeight, Tile * selectTile);

/**
 * Destroys the given slug, freeing its memory.
 * @param slug The slug to free up.
 */
void DestroySlug(SLUG * slug);

//---------------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------------

#define SLUG_SIZE 5
#define HANGAR_WIDTH 5
#define HANGAR_HEIGHT 5


//---------------------------------------------------------------------------------
// Program entry point
//---------------------------------------------------------------------------------
int main(void)
//---------------------------------------------------------------------------------
{

	Tile * tiles = InitTileMatrix(HANGAR_HEIGHT, HANGAR_WIDTH);

	SLUG * slug = CreateSlug(tiles, HANGAR_WIDTH, HANGAR_HEIGHT, SLUG_SIZE);

	dprintf("Sample tile at index 2: %hu, %hu at location %p\n", slug->coords[2]->x, slug->coords[2]->y, slug->coords[2]);

	// Set up the interrupt handlers
	//irqInit();
	// Enable Vblank Interrupt to allow VblankIntrWait
	//irqEnable(IRQ_VBLANK);

	//SetMode(MODE_4 | BG2_ON);		// screen mode & background to display

	// Load all necessary image data
	//graphics_LoadImage(title_pcx, &PaletteBuffer);
	//graphics_LoadImage(title_pulse_pcx, &PulsePaletteBuffer);

	//splash_screen_eff = splash_PulseGray;	// Set the initial screen mode
	//splash_set_pal1(&PaletteBuffer);		// Load the first palette
	//splash_set_pal2(&PulsePaletteBuffer);	// Load the second palette

	//dprintf("Initialised application with palettes %p, %p\n", &PaletteBuffer, &PulsePaletteBuffer);

	while (1)
	{
		//VBlankIntrWait();
		//graphics_Update();
		// Process key inputs
		//input_key_reads();
		//splash_HandleInputs();
	}

	free(tiles);
	DestroySlug(slug);

}

Tile * InitTileMatrix(u16 width, u16 height) {
	
	// Begin by allocating enough memory to store an array of the desired amount of tiles
	Tile * tiles = malloc(sizeof (Tile) * (width * height));

	// Initialise the array to a 
	for (int x = 0; x < width; x++) {
		for (int y = 0; y < height; y++) {
			Tile * tile = &tiles[COORDS_2D(x, height, y)];
			tile->x = x;
			tile->y = y;
			tile->state = EMPTY;
			// dprintf("Initialised Tile %d %d at location %p\n", tile->x, tile->y, tile);
		}
	}

	return tiles;
}

SLUG * CreateSlug(Tile * map, u16 maxWidth, u16 maxHeight, u16 size) {

	int randX;				//< Random x-coordinate buffer
	int randY;				//< Random y-coordinate buffer
	u32 selectedTile = 0;	//< The currently active tile
	bool coordsValid = true;//< Used for checking if the generated coordinates are within range or not

	SLUG * slug = malloc(sizeof * slug);				//< The slug to create
	Tile ** coords = malloc(sizeof (Tile *) * size);	//< The coordinates of the slug

	// Getting the coordinates for the first tile
	randX = qran_range(0, maxWidth);
	randY = qran_range(0, maxHeight);

	// Assigning the first tile to the tile array
	coords[0] = &map[COORDS_2D(randX, maxHeight, randY)];
	coords[0]->state = SLUG_HERE;

	/**
	 * 1. Check if the selected starting tile has empty neighbours.
	 * 1.1. If not, select a different starting tile (at random).
	 * 2. Select a random set of coordinates.
	 * 2.1. Validate those coordinates, making sure they are in range.
	 * 2.2. If the tile is not empty, reiterate until an empty tile is chosen.
	 * 3. Add the tile to the coordinates list.
	 * 4. Mark the newly selected tile as full.
	 * 5. Set the selected starting tile to the new tile.
	 */

	for (int tile = 1; tile < size; tile++) {

		// 1. Checking if tile has empty neighbours.
		while (!TileHasEmptyNeighbours(map, maxWidth, maxHeight, coords[selectedTile])) {
			// 1.1. Reassigning selected tile.
			selectedTile = qran_range(0, tile);
			dprintf("Had to reassign selected tile to %d\n", selectedTile);
		}

		do {

			coordsValid = true;

			// 2. Select random coords.
			// Pick a new adjacent tile around the previous tile's coordinates
			randX = ((qran() % 3) - 1);
			randY = ((qran() % 3) - 1);

			randX += coords[selectedTile]->x;
			randY += coords[selectedTile]->y;

			dprintf("Chose new coordinates %d, %d\n", randX, randY);

			// 2.1. Validate the coordinates are in-range
			if (randX < 0 || randX >= maxWidth) {
				dprintf("X-coord %d invalid\n", randX);
				coordsValid = false;
			}
			if (randY < 0 || randY >= maxHeight) {
				dprintf("Y-coord %d invalid\n", randY);
				coordsValid = false;
			}

		// 2.2. Check if chosen tile is not empty and coords are valid.
		} while (map[COORDS_2D(randX, maxHeight, randY)].state != EMPTY || !coordsValid);

		dprintf("Assigning new tile %d, %d\n", randX, randY);

		// 3. Add the tile to the list of slug tiles.
		coords[tile] = &map[COORDS_2D(randX, maxHeight, randY)];
		// 4. Mark the added tile as full.
		coords[tile]->state = SLUG_HERE;
		
		// 5. Set the new selected tile.
		selectedTile = tile;

		dprintf("Assigned new tile to %d\n", selectedTile);

	}

	slug->coords = coords;	//< Assign the new coords array to the slug.

	// Testing of the assigned coords tiles
	for (int tile = 0; tile < size; tile++) {
		dprintf("Testing referenced Tile %d %d at location %p\n", slug->coords[tile]->x, slug->coords[tile]->y, slug->coords[tile]);
	}

	

	return slug;

}

bool TileHasEmptyNeighbours(Tile * map, int mapWidth, int mapHeight, Tile * selectTile) {
	int coordX, coordY;
	TILE_STATE state;

	// Iterate over all tiles adjacent to the selected block.
	for (int i = -1; i < 2; i++) {
		for (int j = -1; j < 2; j++) {
			// Get the coordinates of the tile to be tested.
			coordX = selectTile->x + i;
			coordY = selectTile->y + j;

			// If the coordinates are out of range, skip to the next tile
			if (coordX < 0 || coordX >= mapWidth) continue;
			if (coordY < 0 || coordY >= mapHeight) continue;

			// If the state of this tile is EMPTY, return true
			state = map[COORDS_2D(coordX, mapHeight, coordY)].state;
			dprintf("Checking state of tile %hu, %hu (%d)\n", coordX, coordY, state);
			if (state == EMPTY) return true;
		}
	}
	return false;
}

void DestroySlug(SLUG * slug) {
	free(slug->coords);
	free(slug);
}

void splash_HandleInputs() {
	if (input_key_pressed(KEY_UP) && splash_screen_eff != splash_PulseGray)				splash_screen_eff = splash_PulseGray;
	else if (input_key_pressed(KEY_RIGHT) && splash_screen_eff != splash_Pulse_Title)	splash_screen_eff = splash_Pulse_Title;
	else if (input_key_pressed(KEY_DOWN) && splash_screen_eff != splash_FadeOut)		splash_screen_eff = splash_FadeOut;
	else if (input_key_pressed(KEY_LEFT))												graphics_TransNewImage(main_menu_pcx);
}