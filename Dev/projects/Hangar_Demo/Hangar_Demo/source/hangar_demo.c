#include "gba_video.h"
#include "gba_systemcalls.h"
#include "gba_input.h"
#include "gba_interrupt.h"
#include "mappy.h"
#include "pcx.h"
#include "fade.h"

#include "tile.h"
#include "slug.h"
#include "splash_scr.h"
#include "graphics_controller.h"
#include "input_controller.h"

//---------------------------------------------------------------------------------
// header for binary data generated by bin2o macro in makefile
//---------------------------------------------------------------------------------
#include "title_pcx.h"
#include "title_pulse_pcx.h"
#include "main_menu_pcx.h"
#include "GROUND_EXP_pcx.h"

void splash_HandleInputs();

//---------------------------------------------------------------------------------
// Function Declarations
//---------------------------------------------------------------------------------

//---------------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------------

#define SLUG_SIZE 5
#define HANGAR_WIDTH 5
#define HANGAR_HEIGHT 5

#define SB_PAGE 31

typedef enum HANGER_TILE_SIZE {
	NONE = 0,
	HANGAR_SMALL,
	HANGAR_MEDIUM,
	HANGAR_LARGE
} HANGAR_TILE_SIZE;

Tile * tiles;
Slug * slug;

#define HANGAR_SIZE HANGAR_MEDIUM
#define HANGAR_SIZE_X HANGAR_WIDTH * HANGAR_SIZE
#define HANGAR_SIZE_Y HANGAR_HEIGHT * HANGAR_SIZE
int startGridX = 3;	//< Starting tile X of slug grid
int startGridY = 3;	//< Starting tile Y of slug grid
int selectX;		//< Selected slug grid tile on X-axis (offset not absolute).
int selectY;		//< Selected slug grid tile on Y-axis (offset not absolute).
int prevX;			//< Previous selected slug grid tile on X-axis (offset not absolute).
int prevY;			//< Previous selected slug grid tile on Y-axis (offset not absolute).

//---------------------------------------------------------------------------------
// Program entry point
//---------------------------------------------------------------------------------
int main(void)
//---------------------------------------------------------------------------------
{

	// Enable Large background, use Screenblock 31 and enable 16-color mode
	REG_BG0CNT = TEXTBG_SIZE_512x512 | SCREEN_BASE(SB_PAGE) | BG_256_COLOR;
	SetMode(MODE_0 | BG0_ON);		// screen mode & background to display

	// Load tile set and palette 
	DecodePCX(GROUND_EXP_pcx, CHAR_BASE_ADR(0), BG_PALETTE);

	tiles = Tile_InitTileMatrix(HANGAR_HEIGHT, HANGAR_WIDTH);
	slug = Slug_CreateSlug(tiles, HANGAR_WIDTH, HANGAR_HEIGHT, SLUG_SIZE);

	dprintf("Sample tile at index 2: %hu, %hu at location %p\n", slug->coords[2]->x, slug->coords[2]->y, slug->coords[2]);

	// Fill the screenblock the default tile
	for (int x = 0; x < 32; x++) {
		for (int y = 0; y < 32; y++) {
			MAP[SB_PAGE][y][x] = 13;
		}
	}

	// Draw the slug ground map
	drawGroundMap(SB_PAGE, HANGAR_SIZE, startGridX, startGridY, HANGAR_WIDTH, HANGAR_HEIGHT);

	// Draw initial starting tile
	drawHangarTile(31, startGridX, startGridY, 1, HANGAR_SIZE);

	// Set up the interrupt handlers
	irqInit();
	// Enable Vblank Interrupt to allow VblankIntrWait
	irqEnable(IRQ_VBLANK);

	// Load all necessary image data
	//graphics_LoadImage(title_pcx, &PaletteBuffer);
	//graphics_LoadImage(title_pulse_pcx, &PulsePaletteBuffer);

	//splash_screen_eff = splash_PulseGray;	// Set the initial screen mode
	//splash_set_pal1(&PaletteBuffer);		// Load the first palette
	//splash_set_pal2(&PulsePaletteBuffer);	// Load the second palette

	//dprintf("Initialised application with palettes %p, %p\n", &PaletteBuffer, &PulsePaletteBuffer);

	while (1)
	{
		VBlankIntrWait();
		//graphics_Update();
		// Process key inputs
		input_key_reads();
		hangar_HandleInputs();
		//splash_HandleInputs();
	}

	free(tiles);
	Slug_DestroySlug(slug);

}

void drawGroundMap(int sb, int tileSize, int startX, int startY, int sizeX, int sizeY) {
	
	int endX = startX + sizeX * tileSize;
	int endY = startY + sizeY * tileSize;

	// From the given start till the given end, set each tile to the slug ground tile
	for (int x = startX; x < endX; x += tileSize) {
		for (int y = startY; y < endY; y += tileSize) {
			drawHangarTile(sb, x, y, 2, HANGAR_SIZE);
		}
	}

}

void hangar_HandleInputs() {

	// Input handling for selected tile x-coordinate movement.
	if (input_key_pressed(KEY_LEFT) && selectX > 0) {
		prevX = selectX;
		selectX -= HANGAR_SIZE;
	} else if (input_key_pressed(KEY_RIGHT) && selectX < HANGAR_SIZE_X - HANGAR_SIZE) {
		prevX = selectX;
		selectX += HANGAR_SIZE;
	}

	// Input handling for selected tile y-coordinate movement
	if (input_key_pressed(KEY_UP) && selectY > 0) {
		prevY = selectY;
		selectY -= HANGAR_SIZE;
	}
	else if (input_key_pressed(KEY_DOWN) && selectY < HANGAR_SIZE_Y - HANGAR_SIZE) {
		prevY = selectY;
		selectY += HANGAR_SIZE;
	}

	if (input_key_pressed(KEY_SELECT)) {
		Slug_DestroySlug(slug);
		slug = Slug_CreateSlug(tiles, HANGAR_WIDTH, HANGAR_HEIGHT, SLUG_SIZE);
	}

	// If the selected tile has changed, mark it as selected and clear the previous tile.
	if (prevX != selectX | prevY != selectY) {
		dprintf("Getting here");
		drawHangarTile(SB_PAGE, startGridX + selectX, startGridY + selectY, 1, HANGAR_SIZE);
		drawHangarTile(SB_PAGE, startGridX + prevX, startGridY + prevY, 2, HANGAR_SIZE);

		prevX = selectX;
		prevY = selectY;
	}

}

void drawHangarTile(int sb, int coordX, int coordY, int tileI, HANGAR_TILE_SIZE size, int altTileI) {

	// dprintf("Received coords %d, %d for tile %d\n", coordX, coordY, tileI);

	switch (size) {

	case HANGAR_SMALL:
		MAP[sb][coordY][coordX] = tileI;
		break;

	case HANGAR_MEDIUM:
		MAP[sb][coordY][coordX] = tileI;
		MAP[sb][coordY][coordX + 1] = tileI | BIT(10);
		MAP[sb][coordY + 1][coordX] = tileI | BIT(11);
		MAP[sb][coordY + 1][coordX + 1] = tileI | BIT(10) | BIT(11);
		break;

	case HANGAR_LARGE:
		MAP[sb][coordY][coordX] = tileI;
		MAP[sb][coordY][coordX + 1] = altTileI;
		MAP[sb][coordY][coordX + 2] = tileI | BIT(10);

		MAP[sb][coordY + 1][coordX] = altTileI;
		MAP[sb][coordY + 1][coordX + 1] = altTileI;
		MAP[sb][coordY + 1][coordX + 2] = altTileI | BIT(10);

		MAP[sb][coordY + 2][coordX] = tileI | BIT(11);
		MAP[sb][coordY + 2][coordX + 1] = altTileI | BIT(11);
		MAP[sb][coordY + 2][coordX + 2] = tileI | BIT(11) | BIT(10);
		break;

	}

}

void splash_HandleInputs() {
	if (input_key_pressed(KEY_UP) && splash_screen_eff != splash_PulseGray)				splash_screen_eff = splash_PulseGray;
	else if (input_key_pressed(KEY_RIGHT) && splash_screen_eff != splash_Pulse_Title)	splash_screen_eff = splash_Pulse_Title;
	else if (input_key_pressed(KEY_DOWN) && splash_screen_eff != splash_FadeOut)		splash_screen_eff = splash_FadeOut;
	else if (input_key_pressed(KEY_LEFT))												graphics_TransNewImage(main_menu_pcx);
}